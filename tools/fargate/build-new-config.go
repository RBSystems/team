package main

import (
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/byuoitav/common/log"
)

//BuildNewService .
func BuildNewService(wrap ConfigInfoWrapper, def ConfigDefinition, dbName, branch string) (NewServiceCloudformationStack, string, error) {
	toReturn := NewServiceCloudformationStack{}

	if _, ok := wrap.AWSStages[branch]; !ok {
		return toReturn, "", fmt.Errorf("No branch information for %v defined", branch)
	}

	err := json.Unmarshal([]byte(newservicetemplate), &toReturn)
	if err != nil {
		log.L.Fatalf("Invalid template, binary is corrupt")
	}

	stageInfo := wrap.AWSStages[branch]

	var ts AWSTaskInfo
	var ok bool

	//we have a task to build
	if len(stageInfo.Task) > 1 {
		taskwrap, err := GetTaskInfoFromDB(stageInfo.Task)
		if err != nil {
			return toReturn, "", fmt.Errorf("Couldn't get task definition %v from database. %v", wrap.AWSStages[branch].Task, err.Error())
		}
		ts, ok = taskwrap.AWSStages[branch]
		if !ok {
			return toReturn, "", fmt.Errorf("No branch information for %v defined in the task definition", branch)
		}

		if branch == "development" {
			//Cluster Info
			toReturn.Resources.Cluster.Properties.ClusterName = ts.Name
		} else {
			toReturn.Resources.Cluster = nil
		}

		//Listener Info
		l := &toReturn.Resources.Listener.Properties
		if len(ts.CertificateArn) > 0 {
			l.Certificates[0].CertificateArn = ts.CertificateArn
			l.Protocol = "HTTPS"
		} else {
			l.Protocol = "HTTP"
		}
		l.Port = ts.PublicPort

		//LoadBalancer info
		lb := &toReturn.Resources.LoadBalancer.Properties
		lb.Name = ts.Name + "--" + branch
		lb.Scheme = "internet-facing"
		lb.Subnets = ts.PublicSubnets
		for k, v := range ts.Tags {
			lb.Tags = append(lb.Tags, Tag{Key: k, Value: v})
		}
		lb.Tags = append(lb.Tags, GenEnvTag(branch))

		// LoadBalancerSecurityGroupa
		lbsg := &toReturn.Resources.LoadBalancerSecurityGroup.Properties
		lbsg.GroupDescription = "Autogenerated security group for " + ts.Name + " " + branch + " load balancer."
		lbsg.GroupName = ts.Name + "--" + branch + " load balancer"

		lbsg.SecurityGroupIngress = []SecurityGroup{}
		lbsg.SecurityGroupIngress = append(lbsg.SecurityGroupIngress, SecurityGroup{
			FromPort:   ts.PublicPort,
			ToPort:     ts.PublicPort,
			IPProtocol: "tcp",
		})
		if ts.Public {
			lbsg.SecurityGroupIngress[0].Description = "All access"
			lbsg.SecurityGroupIngress[0].CidrIP = "0.0.0.0/0"
		} else {
			lbsg.SecurityGroupIngress[0].Description = "BYU Interal addresses"
			lbsg.SecurityGroupIngress[0].CidrIP = "10.0.0.0/8"
			lbsg.SecurityGroupIngress = append(lbsg.SecurityGroupIngress, SecurityGroup{
				Description: "BYU External Addresses",
				CidrIP:      "128.187.0.0/16",
				IPProtocol:  "tcp",
				FromPort:    ts.PublicPort,
				ToPort:      ts.PublicPort,
			})
		}
		for k, v := range ts.Tags {
			lbsg.Tags = append(lbsg.Tags, Tag{Key: k, Value: v})
		}
		lbsg.Tags = append(lbsg.Tags, GenEnvTag(branch))
		lbsg.VpcID = ts.VPCID

		// Regular Security Group stuff
		sg := &toReturn.Resources.SecurityGroup.Properties
		sg.GroupDescription = "Autogenerated security group for " + ts.Name + " " + branch
		sg.GroupName = ts.Name + "--" + branch
		sg.SecurityGroupIngress = []SecurityGroup{}
		sg.SecurityGroupIngress = append(sg.SecurityGroupIngress, SecurityGroup{
			FromPort:    0,
			ToPort:      65535,
			Description: "Internal access",
			CidrIP:      "10.0.0.0/8",
			IPProtocol:  "tcp",
		})
		for k, v := range ts.Tags {
			sg.Tags = append(sg.Tags, Tag{Key: k, Value: v})
		}
		sg.Tags = append(sg.Tags, GenEnvTag(branch))
		sg.VpcID = ts.VPCID

		//Service
		svc := &toReturn.Resources.Service.Properties
		svc.DesiredCount = ts.InstanceCount
		svc.LoadBalancers[0].ContainerName = ts.PublicService
		svc.LoadBalancers[0].ContainerPort = ts.PublicPort //find the port of the public service
		svc.NetworkConfiguration.AwsvpcConfiguration.Subnets = ts.PrivateSubnets
		svc.Role = ts.ServiceRoleArn
		svc.ServiceName = ts.Name + "--" + branch
		svc.Cluster = ts.Name

		//TargetGroup
		tg := &toReturn.Resources.TargetGroup.Properties
		tg.HealthCheckPort = ts.PublicPort
		tg.Name = ts.Name + "--" + branch
		tg.Port = ts.PublicPort
		for k, v := range ts.Tags {
			tg.Tags = append(tg.Tags, Tag{Key: k, Value: v})
		}
		tg.Tags = append(tg.Tags, GenEnvTag(branch))
		tg.VpcID = ts.VPCID

		//LogGroup
		lg := &toReturn.Resources.LogGroup.Properties
		lg.LogGroupName = fmt.Sprintf("/ecs/%v--%v", ts.Name, branch)
		lg.RetentionInDays = 3

		//Task Definition
		tmp, _, err := buildTaskDefinitionConfig(wrap, def, dbName, branch)
		if err != nil {
			log.L.Errorf("Couldn't build task definition")
			return toReturn, "", fmt.Errorf("Couldn't build task definition: %v", err.Error())
		}
		toReturn.Resources.TaskDef = tmp.Resources.Task
		//look through to see if the public port is differnet from the port defined for the pulic service.
		for _, i := range toReturn.Resources.TaskDef.Properties.ContainerDefinitions {
			if i.Name == ts.PublicService {
				if i.PortMappings[0].ContainerPort != string(ts.PublicPort) {
					tmp, er := strconv.Atoi(i.PortMappings[0].ContainerPort)
					if er != nil {
						log.L.Warnf("Container port for public service doesn't match service public port, but can't parse container port: %v.", i.PortMappings[0].ContainerPort)
						break
					}
					log.L.Infof("Using public port %v and container port %v", ts.PublicPort, tmp)
					svc.LoadBalancers[0].ContainerPort = tmp
				} else {
					break
				}
			}
		}

	}

	return toReturn, ts.Name + "--" + branch, nil
}

//GenEnvTag .
func GenEnvTag(branch string) Tag {
	toReturn := Tag{Key: "env"}
	switch branch {
	case "development":
		toReturn.Value = "dev"
	case "stage":
		toReturn.Value = "stg"
	case "production":
		toReturn.Value = "prd"
	default:
		toReturn.Value = branch
	}
	return toReturn

}
